# Visualization 5 - Choropleth Map
How have hate crimes evolved over time across different bias categories (racial, religious, gender-based, etc.)?

```js
viewof selectedCategory = {
  const select = Inputs.select(
    general_categories,
    { label: "Bias Category:" }
  );
  
  return select;
}
```

```js
viewof yearRange = timeRange(new Date(dataYearRange[0]-1, 0), new Date(dataYearRange[1], 0), {
    interval: "year",
    label: "Year Range:",
    value: [new Date(dataYearRange[0]-1, 0), new Date(dataYearRange[1], 0)]
  })
```

```js
chart1 = {
  const width = 975;
  const height = 610;
  
  const path = d3.geoPath();
  const format = d => `${d.toFixed(2)}%`;

  const stateNames = topojson.feature(us, us.objects.states).features.map(f => f.properties.name);
  const valuemap = new Map(stateNames.map(s => [s, (byStatePerCapita.get(selectedCategory).get(years[1]).get(s) - byStatePerCapita.get(selectedCategory).get(years[0])?.get(s)) / byStatePerCapita.get(selectedCategory).get(years[0])?.get(s)]))
  
  const color = d3.scaleDivergingPow()
    .domain([-100, 0, 100])
    .exponent(0.2)
    .interpolator(d3.interpolateRdBu);

  const counties = topojson.feature(us, us.objects.counties);
  const states = topojson.feature(us, us.objects.states);
  const statemap = new Map(states.features.map(d => [d.id, d]));

  const statemesh = topojson.mesh(us, us.objects.states, (a, b) => a !== b);

  const svg = d3.create("svg")
      .attr("width", width)
      .attr("height", height)
      .attr("viewBox", [0, 0, width, height])
      .attr("style", "max-width: 100%; height: auto;");

  svg.append("g")
      .attr("transform", `translate(${height-70},15)`)
      .append(() => Legend(color, {title: "Percentage Change in Hate Crime Incidents Per Capita", width: 350}));

  svg.append("g")
    .selectAll("path")
    .data(topojson.feature(us, us.objects.states).features)
    .join("path")
      .attr("fill", d => {
        if (!Number.isNaN(valuemap.get(d.properties.name))) {
          return color(valuemap.get(d.properties.name))
        } else if (!!byStatePerCapita.get(selectedCategory).get(years[1])?.get(d.properties.name)) { 
          // Starting year data doesn't exist, but end year does
          return "black"
        } else {
          return "#999da0"
        }
      })
      .attr("d", path)
    .append("title")
      .text(d => {
        if (!Number.isNaN(valuemap.get(d.properties.name))) {
          return `${d.properties.name}\n${format(valuemap.get(d.properties.name))}`
        } else if (!!byStatePerCapita.get(selectedCategory).get(years[1])?.get(d.properties.name)) { 
          // Starting year data doesn't exist, but end year does
          return `${d.properties.name}\nMissing data for selected start year`
        } else {
          return `${d.properties.name}\nNo data for range`
        }
      });

  svg.append("path")
      .datum(topojson.mesh(us, us.objects.states, (a, b) => a !== b))
      .attr("fill", "none")
      .attr("stroke", "white")
      .attr("stroke-linejoin", "round")
      .attr("d", path);

  return svg.node();
}
```

# Visualization 6 - Sankey Diagram
Are there specific incident types (e.g. vandalism, assault, intimidation, etc.) more prevalent within specific bias categories?

```js
chart = {
  // Specify the dimensions of the chart.
  const width = 1000;
  const height = 2000;
  const format = d3.format(",.0f");

  // Create a SVG container.
  const svg = d3.create("svg")
      .attr("width", width)
      .attr("height", height)
      .attr("viewBox", [0, 0, width, height])
      .attr("style", "max-width: 100%; height: auto; font: 10px sans-serif;");

  // Constructs and configures a Sankey generator.
  const sankey = d3.sankey()
      .nodeId(d => d.name)
      .nodeAlign(d3["sankeyJustify"])
      .nodeWidth(15)
      .nodePadding(10)
      .extent([[1, 5], [width - 1, height - 5]]);

  // Applies it to the data. We make a copy of the nodes and links objects
  // so as to avoid mutating the original.
  const {nodes, links} = sankey({
    nodes: data.nodes.map(d => Object.assign({}, d)),
    links: data.links.map(d => Object.assign({}, d))
  });

  // Defines a color scale.
  const color = d3.scaleOrdinal(d3.schemePaired);

  // Creates the rects that represent the nodes.
  const rect = svg.append("g")
      .attr("stroke", "#000")
    .selectAll()
    .data(nodes)
    .join("rect")
      .attr("x", d => d.x0)
      .attr("y", d => d.y0)
      .attr("height", d => d.y1 - d.y0)
      .attr("width", d => d.x1 - d.x0)
      .attr("fill", d => color(d.name));

  // Adds a title on the nodes.
  rect.append("title")
      .text(d => `${d.name}\n${format(d.value)} incidents`);

  // Creates the paths that represent the links.
  const link = svg.append("g")
      .attr("fill", "none")
      .attr("stroke-opacity", 0.5)
    .selectAll()
    .data(links)
    .join("g")
      .style("mix-blend-mode", "multiply");

  // Creates a gradient, if necessary, for the source-target color option.

    const gradient = link.append("linearGradient")
        .attr("id", d => (d.uid = DOM.uid("link")).id)
        .attr("gradientUnits", "userSpaceOnUse")
        .attr("x1", d => d.source.x1)
        .attr("x2", d => d.target.x0);
    gradient.append("stop")
        .attr("offset", "0%")
        .attr("stop-color", d => color(d.source.name));
    gradient.append("stop")
        .attr("offset", "100%")
        .attr("stop-color", d => color(d.target.name));

  link.append("path")
      .attr("d", d3.sankeyLinkHorizontal())
      .attr("stroke", (d) => d.uid)
      .attr("stroke-width", d => Math.max(1, d.width));

  link.append("title")
      .text(d => `${d.source.name} â†’ ${d.target.name}\n${format(d.value)} incidents`);

  // Adds labels on the nodes.
  svg.append("g")
    .selectAll()
    .data(nodes)
    .join("text")
      .attr("x", d => d.x0 < width / 2 ? d.x1 + 6 : d.x0 - 6)
      .attr("y", d => (d.y1 + d.y0) / 2)
      .attr("dy", "0.35em")
      .attr("text-anchor", d => d.x0 < width / 2 ? "start" : "end")
      .text(d => d.name);

  return svg.node();
}
```

```js
d3 = require("d3@7", "d3-sankey@0.12")
```

```js
rawData = FileAttachment("data/new_final_hate_crimes.csv").csv();
```

```js
function addGeneralCategory(row) {
  const catMap = {
    "Anti-American Indian or Alaska Native": "Race/Ethnicity/Ancestry",
    "Anti-Arab": "Race/Ethnicity/Ancestry",
    "Anti-Asian": "Race/Ethnicity/Ancestry",
    "Anti-Black or African American": "Race/Ethnicity/Ancestry",
    "Anti-Hispanic or Latino": "Race/Ethnicity/Ancestry",
    "Anti-Multiple Races, Group": "Race/Ethnicity/Ancestry",
    "Anti-Native Hawaiian or Other Pacific Islander": "Race/Ethnicity/Ancestry",
    "Anti-Other Race/Ethnicity/Ancestry": "Race/Ethnicity/Ancestry",
    "Anti-White": "Race/Ethnicity/Ancestry",
    "Anti-Buddhist": "Religion",
    "Anti-Catholic": "Religion",
    "Anti-Eastern Orthodox (Russian, Greek, Other)": "Religion",
    "Anti-Hindu": "Religion",
    "Anti-Islamic (Muslim)": "Religion",
    "Anti-Jehovah's Witness": "Religion",
    "Anti-Jewish": "Religion",
    "Anti-Mormon": "Religion",
    "Anti-Church of Jesus Christ": "Religion",
    "Anti-Multiple Religions, Group": "Religion",
    "Anti-Other Christian": "Religion",
    "Anti-Other Religion": "Religion",
    "Anti-Protestant": "Religion",
    "Anti-Sikh": "Religion",
    "Anti-Atheism/Agnosticism": "Religion",
    "Anti-Bisexual": "Sexual Orientation",
    "Anti-Gay (Male)": "Sexual Orientation",
    "Anti-Heterosexual": "Sexual Orientation",
    "Anti-Lesbian (Female)": "Sexual Orientation",
    "Anti-Lesbian, Gay, Bisexual, or Transgender (Mixed Group)": "Sexual Orientation",
    "Anti-Mental Disability": "Disability",
    "Anti-Physical Disability": "Disability",
    "Anti-Male": "Gender",
    "Anti-Female": "Gender",
    "Anti-Transgender": "Gender Identity",
    "Anti-Gender Non-Conforming": "Gender Identity",
    "Unknown (offender's motivation not known)": "Unknown"
  }
  row.general_category = catMap[row.bias_desc]
  return row
}
```

```js
processedData = {
  let rows = [];
  rawData.filter(r => parseInt(r.data_year) >= 2000).forEach(d => {
    const incidentTypes = d.offense_name.split(";");
    if (incidentTypes.length == 1) {
      rows.push({
        ...d,
        offense_name: d.offense_name,
        bias_desc: d.bias_desc,
        count: 1
      })
    } else {
      incidentTypes.forEach(incidentType => rows.push({
        ...d,
        offense_name: incidentType,
        bias_desc: d.bias_desc,
        count: 1/incidentTypes.length
      }))
    }
  })

  let rowsSplit = [];
  rows.forEach(d => {
    const categories = d.bias_desc.split(";");
    if (categories.length == 1) {
      rowsSplit.push(d)
    } else {
      categories.forEach(cat => rowsSplit.push({
        ...d,
        offense_name: d.offense_name,
        bias_desc: cat,
        count: d.count/categories.length
      }))
    }
  })
  return rowsSplit.map(addGeneralCategory);
}
```

```js
biases = Array.from(new Set(processedData.map(d => d.bias_desc)))
```

```js
offenses = Array.from(new Set(processedData.map(d => d.offense_name)))
```

```js
general_categories = Array.from(new Set(processedData.map(d => d.general_category)))
```

```js
statesInData = Array.from(new Set(processedData.map(d => d.state_name)))
```

```js
function buildSankeyData(rows) {
  const nodes = [];
  const nodeByName = new Map(); // key: name, value: node index

  function getNode(name, level) {
    const key = `${level}:${name}`;
    if (!nodeByName.has(key)) {
      nodeByName.set(key, nodes.length);
      nodes.push({ name, level });
    }
    return nodeByName.get(key);
  }

  // Use maps to aggregate link values
  const linkMap = new Map(); // key: "sourceIndex|targetIndex" -> value

  function addLink(sourceIndex, targetIndex, value) {
    const key = `${sourceIndex}|${targetIndex}`;
    const current = linkMap.get(key) || 0;
    linkMap.set(key, current + value);
  }

  for (const d of rows) {
    const g = getNode(d.general_category, "general");
    const b = getNode(d.bias_desc, "bias");
    const i = getNode(d.offense_name, "incident");

    // bias_desc -> general_category
    addLink(d.bias_desc, d.general_category, d.count);

    // bias_desc -> offense_name
    addLink(d.general_category, d.offense_name, d.count);
  }

  const links = Array.from(linkMap, ([key, value]) => {
    const [source, target] = key.split("|");
    return { source, target, value };
  });

  return { nodes, links };
}

```

```js
data = buildSankeyData(processedData)
```

```js
rawPopulationData = await FileAttachment("data/population.csv").csv()
```

```js
populationData = d3.group(rawPopulationData, d => d.STNAME, d => d.CTYNAME)
```

```js
processedDataForMap = processedData.filter(d => !["Federal", "Guam"].includes(d.state_name))
```

```js
byState = d3.rollup(processedData, v => d3.sum(v, d => d.count), d => d.general_category, d => d.data_year, d => d.state_name)
```

```js
byCounty = d3.rollup(processedData, v => d3.sum(v, d => d.count), d => d.general_category, d => d.data_year, d => d.pug_agency_name)
```

```js
byStatePerCapita = d3.rollup(
  processedDataForMap,
  v => d3.sum(v, d => d.count/(populationData.get(d.state_name).get(d.state_name)[0][parseInt(d.data_year)])), 
  d => d.general_category, 
  d => d.data_year, 
  d => d.state_name)
```

```js
import {timeRange} from "@jwolondon/time-range-input"
```

```js
import {us} from "@d3/us-state-choropleth/2"
```

```js
import {Legend} from "@d3/color-legend"
```

```js
dataYearRange = {
  const keys = [...byState.get(selectedCategory).keys()]
  const firstYear = parseInt(keys[0])
  const finalYear = parseInt(keys[keys.length-1])
  return [firstYear, finalYear]
}
```

```js
years = yearRange.map(d => (d.getFullYear()+1).toString())
```
